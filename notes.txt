Python Builtins

Tuple: used as a row in a database
    record = (val1, val2, val3)
    a, b, c = record
    val = record(s)

row = ('cat', 'dog', 'pet', 'bird', 'reptile')

from collections import namedtuple
Attendee = namedtuple('Attendee', ['first', 'middle', 'last'])
row = Attendee ('Emily', 'Quinn', 'Finney')
row.first = 'Emily'


List: used as an array, mutable sequence, enforces order
    items = [val1, val2, ... valn]
    x = items[n]
    items[n] = x
    del items[n]
    items.append(val_{n+1})
    items.sort()


Set: like a list, except that it deletes non-unique values, membership testing
    s = {val1, val2, ... valn}
    s.add(val)
    s.remove(val)
    val in s

row = ['cat', 'dog', 'pet', 'bird', 'reptile', 'cat']
row = {'cat', 'dog', 'pet', 'bird', 'reptile', 'cat'}
row will present as {'cat', 'dog', 'pet', 'bird', 'reptile'}


Dict: maps keys with items, associative array, lookup tables
    d = {key1: val1, key2: val2, key3: val3}
    val = d[key]
    d[key] = val
    del d[key]
    key in d

fines = {'cat': 20.07, 'dog': 65.92, 'bird': 87.80, 'reptile': 0.08}
prices['cat'] will present as 20.07


Counter: used to count, create histograms, tabulate data structures
    c = Counter(sequence)
    c[key] += n
    c.most_common(n)
    
from collections import Counter
c = Counter(['cat', 'dog', 'cat'])
c will present as Counter({'cat': 2, 'dog': 1})
c['cat'] += 10
c['dog'] += 20
c will present as Counter({'dog': 21, 'cat': 12})


defaultdict: used to make dictionaries with a one-to-many relationship
    d = defaultdict(list)
    d[key].append(val)
    values = d[key]
    d = defaultdict(set)
    d[key].add(val)
    unique_values = d[key]

d = defaultdict(list)
d['cat'].append(12)
d['dog'].append(9)
d['cat'].append(1)
d will present as {'dog': [9], 'cat': [12, 1]}


Iteration:
    for item in container:
        ...

    for n, item in enumerate(container):
        ...

    for item1, item2 in zip(container1, container2):
        ...

Reduction:
    sum(container)
    min(container)
    max(container)
    any(container)
    all(container)


Comprehensions:
    List comprehension:
        [expression for x in iterable if condition]

    Set comprehension:
    	{expression for x in iterable if condition}

    Dict comprehension:
    	{key: val for key, val in iterable if condition}

nums = [1,2,3,4,5,6]
squares = [ x*x for x in nums]


DATA MUNGING
import csv
food = list(csv.DictReader(open('Food_inspections.csv')))
len, look at records
Set comprehension: {row['Results'] for row in food}
List comprehension: [row for row in food if row['Results'] == 'Fail']
Using a counter: worst = Counter(row['DBA Name'] for row in fail)
worst.most_common[5] yields the top five DBA names in the counter worst

Cleaning step:
fail = [{**row, 'DBA Name': row['DBA Name'].replace("'",'').upper()}
         for row in fail]

by_year = defaultdict(Counter)
for row in fail:
    by_year[row['Inspection Data'][-4:]][row['Address']] += 1
by_year['2015'].most_common[5]

ohare = [row for row in fail if row['Address'].startswith('11601 W TOUHY')]

ohare[1]['Violations'].split('|').strip()
    creates a list of individual violations without whitespace



MY STUFF
import csv
imdb = list(csv.DictReader(open('movie_metadata.csv')))
len(imdb)
len(imdb[0])
imdb[0]
{row['aspect_ratio'] for row in imdb}
budget = [row['budget'] for row in imdb if row['country'] == 'USA']
imdb_score = [row['imdb_score'] for row in imdb if row['country'] == 'USA']

clean_budget = []
clean_imdb = []
for b,i in zip(budget, imdb_score):
    if (b != '') and (i != ''):
        clean_budget.append(float(b))
        clean_imdb.append(float(i))

import matplotlib.pyplot as plt
plt.scatter(clean_budget, clean_imdb)

Mkay, so we can do interesting data exploration with the
dictionary thing, but for the plotting we should restrict it to
the numerical data.

Interesting note: the average IMDB score is > 5.
Interesting note: make sure that we check country = USA.

rithmschool.com
